# CLAUDE.md

이 파일은 Claude Code (claude.ai/code)가 이 저장소에서 작업할 때 필요한 가이드를 제공합니다.

## 프로젝트 개요

이 프로젝트는 6주차 부트캠프 과제를 위한 React + TypeScript 게시물 관리 애플리케이션입니다. 다음과 같은 클린 아키텍처 원칙 적용에 중점을 두고 있습니다:

- Feature-Sliced Design (FSD) 아키텍처를 사용한 관심사 분리
- 전역 상태 관리 구현 (Context API, Jotai, 또는 Zustand)
- 컴포넌트 중심 코드를 더 작은 단일 책임 컴포넌트로 리팩토링
- 적절한 TypeScript 타이핑 추가
- 서버 상태 관리를 위한 TanStack Query 구현 (심화 과제)

## 개발 명령어

### 핵심 명령어
- `pnpm dev` - Vite로 개발 서버 시작
- `pnpm build` - 프로덕션 빌드 (TypeScript 컴파일 + Vite 빌드)
- `pnpm preview` - 프로덕션 빌드 로컬 미리보기

### 코드 품질 명령어
- `pnpm lint` - ESLint로 코드 품질 검사
- `pnpm lint:fix` - ESLint 이슈 자동 수정
- `pnpm format` - Prettier로 코드 포맷팅 검사
- `pnpm format:fix` - 코드 자동 포맷팅

### 테스트 명령어
- `pnpm test` - Vitest로 테스트 실행
- `pnpm coverage` - 커버리지 리포트와 함께 테스트 실행

## 아키텍처 요구사항

### 현재 상태 (레거시)
코드베이스에는 현재 다음과 같은 리팩토링이 필요한 문제들이 있습니다:
- 크고 복잡한 컴포넌트 (PostsManagerPage.tsx가 ~726줄)
- 부족한 TypeScript 타이핑
- 적절한 상태 관리 없음 (모든 것이 useState)
- 관리되지 않는 useEffect 의존성
- 컴포넌트 전체에 흩어진 복잡한 비동기 로직

### 목표 아키텍처 (FSD)
프로젝트는 다음 레이어를 가진 Feature-Sliced Design을 사용하여 리팩토링되어야 합니다:
- `shared/` - 공통 컴포넌트 및 유틸리티
- `entities/` - 비즈니스 엔티티 (Post, Comment, User 타입 및 모델)
- `features/` - 사용자 상호작용 및 비즈니스 로직
- `widgets/` - 재사용 가능한 조합 컴포넌트
- `pages/` - 애플리케이션 페이지

### 주요 리팩토링 목표
1. **전역 상태 관리**: Context API, Jotai, 또는 Zustand 구현
2. **컴포넌트 분해**: PostsManagerPage를 더 작은 컴포넌트들로 분리
3. **TypeScript 강화**: 코드베이스 전체에 적절한 타이핑 추가
4. **FSD 구조**: FSD 원칙에 따른 코드 구성
5. **서버 상태 관리**: fetch/useState를 TanStack Query로 교체 (심화)

## 기술적 세부사항

### API 통합
- `vite.config.ts`에서 `/api/*`를 `https://dummyjson.com`으로 프록시 설정
- 주요 엔드포인트: posts, comments, users, tags
- 모든 API 호출은 현재 네이티브 fetch 사용 (TanStack Query로 교체 필요)

### UI 컴포넌트
- `src/components/index.tsx`의 커스텀 컴포넌트 라이브러리
- Radix UI 프리미티브 기반 (@radix-ui/react-dialog, @radix-ui/react-select)
- 변형 스타일링을 위한 class-variance-authority 사용
- 아이콘을 위한 Lucide React

### 현재 컴포넌트 구조
- `PostsManagerPage.tsx` - 메인 페이지 컴포넌트 (대폭 리팩토링 필요)
- `App.tsx` - 라우팅이 포함된 루트 애플리케이션 컴포넌트
- `Header.tsx`, `Footer.tsx` - 레이아웃 컴포넌트
- `components/index.tsx` - 공유 UI 컴포넌트 라이브러리

### 유지해야 할 주요 기능
- 게시물 CRUD 작업 (생성, 읽기, 업데이트, 삭제)
- 댓글 관리
- 사용자 정보 모달
- 태그 기반 필터링
- 검색 기능
- 페이지네이션
- URL 상태 동기화

## 개발 노트

### 기술 스택
- React 19 + TypeScript
- 번들링을 위한 Vite
- 내비게이션을 위한 React Router
- 접근성 있는 컴포넌트를 위한 Radix UI
- Axios 사용 가능하지만 현재 미사용
- 테스트를 위한 Vitest + Testing Library
- API 모킹을 위한 MSW (사용 가능하지만 미설정)

### 패키지 매니저
- 패키지 매니저로 `pnpm` 사용 (`pnpm-lock.yaml`로 확인)

### 코드 품질 도구
- React hooks 및 refresh 플러그인이 포함된 ESLint
- 포맷팅을 위한 Prettier
- TypeScript strict 모드 활성화

리팩토링 작업을 진행할 때는 기존 기능을 유지하면서 코드 구성을 개선하고 FSD 아키텍처 패턴을 구현하는 것을 우선시하세요.

## 개발 가이드라인

### 🔧 코딩 스타일 가이드

**함수형 프로그래밍 우선**
- 화살표 함수 선호
- 순수 함수와 불변성 추구
- 고차 함수 활용 (map, filter, reduce 등)

**ES6+ 최신 문법 적극 활용**
- 구조분해 할당 (destructuring)
- 전개연산자 (spread operator)
- 템플릿 리터럴 (template literals)
- 옵셔널 체이닝 (optional chaining)
- Nullish 병합 연산자 (??)

**타이핑 전략**
- 매개변수와 복잡한 반환값: 명시적 타입 선언
- 간단한 변수: TypeScript 추론 활용
- 인터페이스보다 타입 별칭 선호

### 🏗️ 컴포넌트 설계 원칙

**단일 책임 기반 작은 컴포넌트**
- 하나의 명확한 역할만 담당
- 가독성과 테스트 용이성 확보
- 컴포넌트당 50줄 이내 권장

**Props 설계 전략**
- **엔티티 컴포넌트**: 구체적이고 명시적인 props 설계
- **UI 컴포넌트**: 유연하고 재사용 가능한 props 설계
- Props drilling 최소화를 위한 상태 관리 활용

**재사용성 vs 가독성**
- 가독성 우선 원칙
- 3회 이상 반복 시에만 재사용 컴포넌트 고려
- 조기 추상화 지양

### 📁 아키텍처 선택사항

**폴더 구조**
- 타입별 구조 선호 (기능별 구조보다)
- FSD 레이어 기반 조직화
- 관련 파일들의 명확한 분리

**Import 전략**
- 절대 경로 선호 (`@/shared/ui` 형태)
- 상대 경로는 같은 폴더 내에서만 사용
- Barrel Exports 사용 안함 (명시적 import 선호)

**상태관리**
- Jotai 선호 (Context API보다 성능상 이점)
- 아토믹한 상태 관리
- 서버 상태와 클라이언트 상태 명확한 분리

### 🔍 코드 리뷰 체크리스트 (우선순위별)

1. **네이밍 (최우선)** - 명확하고 의도가 드러나는 이름
   - 함수: 동사 + 명사 조합
   - 변수: 명사 위주
   - boolean: is/has/can 접두사

2. **함수 길이 및 복잡성** - 단일 책임으로 분리
   - 하나의 함수는 하나의 일만
   - 중첩 if문 최소화
   - Early return 패턴 활용

3. **중복 코드 제거** - 공통 함수 추출
   - DRY 원칙 준수
   - 공통 로직의 유틸 함수화

4. **에러 처리** - 방어적 프로그래밍
   - 예상 가능한 에러 상황 대비
   - 적절한 폴백 UI 제공

5. **성능 최적화** - 필요 시 메모이제이션
   - React.memo, useMemo, useCallback 적절한 활용
   - 불필요한 리렌더링 방지

### 📏 코드 품질 기준

**품질 지표**
- 정량적 기준보다 정성적 원칙 우선
- 함수 길이: 줄 수보다 단일 책임 준수 여부
- Props 개수: 개수보다 관심사 분리 정도
- 파일 길이: 줄 수보다 응집도와 결합도 균형

**코드 품질 도구**
- ESLint 엄격한 룰 적용
- Prettier 일관된 포맷팅
- TypeScript strict 모드 활성화

**주석 스타일**
- 인라인 주석 우선
- 과도한 JSDoc 지양
- 코드로 의도를 표현하되, 필요시에만 주석 추가

### 🤖 AI 에이전트 작업 규칙

**디자인 및 스타일 변경 정책**
- 코드 리팩토링이나 기능 구현 시 **기존 디자인과 스타일을 유지**
- 사용자가 명시적으로 디자인 변경을 요청하지 않는 한 UI/스타일 변경 금지
- 클래스명, 스타일링, 레이아웃은 기존 코드와 동일하게 유지
- 기능적 개선에만 집중하고 시각적 요소는 보존

**작업 범위 제한**
- 요청받지 않은 디자인 개선 제안 자제
- 코드 구조 개선 시에도 사용자 인터페이스는 그대로 유지
- 스타일 관련 변경이 필요한 경우 사용자에게 먼저 확인 요청

**코드 리뷰 및 피드백 정책**
- **기존 코드에 대한 직설적 피드백 필수**: 잘못된 코드나 개선점을 발견했을 때 명확하게 지적
- **"존중"보다 "정확성" 우선**: 사용자의 코드가 틀렸거나 비효율적이면 솔직하게 표현
- **구체적인 문제점 명시**: "이 부분이 문제입니다", "이렇게 하면 버그가 발생할 수 있습니다" 등 명확한 표현 사용
- **개선 방안 제시**: 문제점을 지적할 때 반드시 올바른 해결 방법도 함께 제공
- **베스트 프랙티스 강조**: 업계 표준이나 권장 패턴과 다를 때 적극적으로 알림

**의도 파악 및 방향성 제시**
- **코드의 진짜 목적 파악**: "이 코드는 XX를 하려고 하는 것 같은데 맞나요?"
- **숨겨진 의도 추론**: 겉으로 보이는 것 외에 실제 달성하려는 목표 파악
- **방향성 명확화**: "지금 이 방향으로 가고 있는데, 원하는 결과는 YY인가요?"
- **더 나은 접근법 제안**: 현재 방식보다 목적에 맞는 더 효과적인 방법 제시
- **전체적인 그림 설명**: 개별 코드가 전체 시스템에서 어떤 역할을 하는지 명시

**금지사항**
- "괜찮은 코드입니다만..." 같은 완곡한 표현 사용 금지
- 명백한 문제를 넘어가거나 묵인하는 행위 금지
- 잘못된 코드를 그대로 두고 작업을 진행하는 것 금지
- 코드의 목적을 추측만 하고 명확히 하지 않는 것 금지